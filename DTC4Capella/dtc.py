"""
/*********************************************************************
* Copyright (c) {November 2025} authors:[Daniel Melero]
*
* This program and the accompanying materials are made
* available under the terms of the Eclipse Public License 2.0
* which is available at https://www.eclipse.org/legal/epl-2.0/
*
* SPDX-License-Identifier: EPL-2.0
********
"""
# name           : Export Dataflow Tabular Chart
# script-type    : Python
# description    : Export Dataflow Tabular Chart as an svg file of the selected Functional Chain
# popup          : enableFor(org.polarsys.capella.core.data.fa.impl.FunctionalChainImpl)

from dataclasses import dataclass
from abc import ABC, abstractmethod
from typing import Dict, Optional
from pathlib import Path

import xml.etree.ElementTree as ET

# include needed for the Capella modeller API
include('workspace://Python4Capella/simplified_api/capella.py')
if False:
    from simplified_api.capella import *
    
# include needed for utilities
include('workspace://Python4Capella/utilities/CapellaPlatform.py')
if False:
    from utilities.CapellaPlatform import *

elem = FunctionalChain(CapellaPlatform.getFirstSelectedElement())

model_path = CapellaPlatform.getModelPath(elem)
project_name = model_path[0:model_path.index("/", 1)]
folder = CapellaPlatform.getFolder(CapellaPlatform.getProject(project_name), "exported_diagrams")


# if len(argv) != 1:
#     aird_path = "/MailDMZ/MailDMZ.aird"
# else:
#     aird_path = argv[0]
#
#
# print(f"[+] Testing \"{aird_path.split('/')[-1]}\"...")
#
# model = CapellaModel()
# model.open(aird_path)
#
# se = model.get_system_engineering()
# print("The model name is " + se.get_name())

@dataclass
class SystemBox:
    """Represents a system box in the diagram"""
    start: int
    end: int
    label: str

@dataclass
class FunctionArrow:
    """Represents a function arrow in the diagram"""
    x: int
    height: int
    label: str

@dataclass
class ProtocolBox:
    """Represents a protocol box in the diagram"""
    x: int
    y: int
    len: int
    label: str

class OutputDriver(ABC):
    """Abstract base class for output drivers"""
    
    def __init__(self, verbose: bool = False, max_prot_level: int = 0):
        self.verbose = verbose
        self.max_prot_level = max_prot_level
        self.config = {}
    
    @abstractmethod
    def init_out(self, prot_boxes: List[List[Optional[ProtocolBox]]], 
                 function_arrows: List[FunctionArrow], 
                 system_boxes: List[SystemBox], 
                 config: Dict[str, Any]):
        pass
    
    @abstractmethod
    def make_system_box(self, box: SystemBox):
        pass
    
    @abstractmethod
    def make_prot_box(self, box: ProtocolBox):
        pass
    
    @abstractmethod
    def make_function_arrow(self, arrow: FunctionArrow):
        pass
    
    @abstractmethod
    def save(self, filename: str):
        pass


class SVGOutput(OutputDriver):
    """SVG output driver"""
    
    def __init__(self, verbose: bool = False, max_prot_level: int = 0):
        super().__init__(verbose, max_prot_level)
        self.svg_root = None
        self.prot_shift_x = 60
        self.prot_shift_y = 30
        self.prot_size_x = 150
        self.prot_size_y = 45
        self.font = 'Arial'
        self.font_size = 12
        self.prot_box_colors = []
        self.system_box_color = "rgb(200,200,200)"
    
    def _load_config(self, config: Dict[str, Any]):
        """Load configuration settings"""
        self.prot_shift_x = config.get('prot_shift_x', 60)
        self.prot_shift_y = config.get('prot_shift_y', 30)
        self.prot_size_x = config.get('prot_size_x', 150)
        self.prot_size_y = config.get('prot_size_y', 45)
        self.font = config.get('font', 'Arial')
        self.font_size = config.get('font_size', 12)
        
        # Default protocol box colors
        default_color = "rgb(213,184,127)"
        self.prot_box_colors = [default_color] * self.max_prot_level
    
    def init_out(self, config: Dict[str, Any]):
        """Initialize SVG output"""
        self.config = config
        self._load_config(config)
        
        if self.verbose:
            print("creating SVG image...")
        
        # Create SVG root element
        self.svg_root = ET.Element('svg')
        self.svg_root.set('xmlns', 'http://www.w3.org/2000/svg')
        self.svg_root.set('width', '100%')
        self.svg_root.set('height', '100%')
        
        # Add comment
        comment = ET.Comment('Generated by dtc.py - Python conversion of dtc by Yves Rűtschlé')
        self.svg_root.append(comment)
        
        # Add marker for arrows
        defs = ET.SubElement(self.svg_root, 'defs')
        marker = ET.SubElement(defs, 'marker')
        marker.set('id', 'triangleMarker')
        marker.set('markerWidth', '8')
        marker.set('markerHeight', '8')
        marker.set('refX', '0')
        marker.set('refY', '4')
        marker.set('orient', 'auto')
        
        path = ET.SubElement(marker, 'path')
        path.set('d', 'M0,0 L0,8 L4,4 L0,0')
        path.set('style', 'fill: #000000;')
    
    def make_system_box(self, box: SystemBox):
        """Create a system box"""
        if self.verbose:
            print(f"Creating system box: {box.label}")
        
        yd = self.font_size
        
        rect = ET.SubElement(self.svg_root, 'rect')
        rect.set('x', str(box.start * self.prot_size_x + self.prot_shift_x - self.prot_size_x * 0.33))
        rect.set('y', str(self.prot_shift_y - 2 * yd))
        rect.set('width', str((box.end - box.start + 0.66) * self.prot_size_x))
        rect.set('height', str(self.max_prot_level * self.prot_size_y + self.prot_shift_y + self.prot_size_y * 0.5))
        rect.set('stroke', 'black')
        rect.set('stroke-width', '1')
        rect.set('fill', self.system_box_color)
        
        text = ET.SubElement(self.svg_root, 'text')
        text.set('x', str(box.start * self.prot_size_x + self.prot_shift_x - self.prot_size_x * 0.33 + 5))
        text.set('y', str(self.prot_shift_y - yd))
        text.set('style', f'font-family: {self.font}; font-size: {self.font_size}px;')
        text.text = box.label
    
    def make_prot_box(self, box: ProtocolBox):
        """Create a protocol box"""
        if box.label == 'void':
            return
        
        color = self.prot_box_colors[box.y] if box.y < len(self.prot_box_colors) else self.prot_box_colors[0]
        
        rect = ET.SubElement(self.svg_root, 'rect')
        rect.set('x', str(box.x * self.prot_size_x + self.prot_shift_x))
        rect.set('y', str(box.y * self.prot_size_y + self.prot_shift_y))
        rect.set('width', str(box.len * self.prot_size_x))
        rect.set('height', str(self.prot_size_y))
        rect.set('stroke', 'black')
        rect.set('stroke-width', '1')
        rect.set('fill', color)
        
        text = ET.SubElement(self.svg_root, 'text')
        text.set('x', str((box.x + box.len/2) * self.prot_size_x + self.prot_shift_x))
        text.set('y', str((box.y + 0.5) * self.prot_size_y + self.font_size / 2 + self.prot_shift_y))
        text.set('style', f'font-family: {self.font}; font-size: {self.font_size}px; text-anchor: middle')
        text.text = box.label
    
    def make_function_arrow(self, arrow: FunctionArrow):
        """Create a function arrow"""
        end_x = arrow.x * self.prot_size_x + self.prot_shift_x
        end_y = (self.max_prot_level + 1) * self.prot_size_y + self.prot_shift_y
        
        line = ET.SubElement(self.svg_root, 'line')
        line.set('x1', str(end_x))
        line.set('y1', str((self.max_prot_level - arrow.height) * self.prot_size_y + self.prot_shift_y))
        line.set('x2', str(end_x))
        line.set('y2', str(end_y))
        line.set('stroke', 'black')
        line.set('stroke-width', '4')
        line.set('stroke-linecap', 'round')
        line.set('style', 'marker-end: url(#triangleMarker);')
        
        text = ET.SubElement(self.svg_root, 'text')
        text.set('x', str(end_x - 18))
        text.set('y', str(end_y + 5))
        text.set('style', f'font-family: {self.font}; font-size: {self.font_size}px; text-anchor: end;')
        text.set('transform', f'rotate(-90,{end_x},{end_y})')
        text.text = arrow.label
    
    def _draw_arrow(self, x: float, y: float, color: str) -> ET.Element:
        """Draw an arrow shape"""
        x_coords = [0, 10, 10, 25, 25, 10, 10, 0]
        y_coords = [0, -20, -10, -10, 10, 10, 20, 0]
        
        points = []
        for i in range(len(x_coords)):
            points.append(f"{x_coords[i] + x},{y_coords[i] + y}")
        
        path = ET.SubElement(self.svg_root, 'path')
        path.set('d', f'M{" L".join(points)} Z')
        path.set('style', f'fill: {color}; stroke: black; stroke-width: 1')
        
        return path

    def save(self, filename: str):
        """Save SVG to file"""
        if self.verbose:
            print(f"saving to {filename}")
        
        # Create the XML declaration and pretty-print the SVG
        xml_str = ET.tostring(self.svg_root, encoding='unicode')
        
        with open(filename, 'w') as f:
            f.write('<?xml version="1.0" encoding="UTF-8"?>\n')
            f.write(xml_str)


# Get list of property names from an Exchange Item Element's type
def read_properties(properties):
    result = []
    for prop in properties.get_contained_properties():
        prop_type = prop.get_type()
        if isinstance(prop_type, Class):
            result += read_properties(prop_type)
        else:
            result.append(prop.java_object.getName())
    return result

# List properties of an Exchange Item
def list_layers(item):
    els = item.get_owned_elements()
    if els.size() != 1:
        raise Exception(f"Exchange Item '{item.get_name()}' do not have one and only one Exchange Item Element")

    types = els[0].get_type()
    if types.size() != 1:
        raise Exception(f"Exchange Item Element '{els[0].get_label()}' do not have one and only one Type")

    return read_properties(types[0])

class Protocol():
    def __init__(self, item: ExchangeItem, x: int, level: int):
        self.item = item
        self.prot_boxes: List[ProtocolBox] = []
        self.is_open = False
        self.level = level
        self.open(x)
    
    def add_hop(self):
        self.prot_boxes[-1].len += 1
        
    def close(self):
        if not self.is_open:
            # TODO: Create ProtocolException
            raise Exception(f"Error: Incoming Exchange Item '{self.item.get_name()}' doesn't correspond with any Outgoing Exchange Item")
        self.is_open = False
    
    def open(self, x: int):
        if self.is_open:
            # TODO: Create ProtocolException
            raise Exception(f"Error: Outgoing Exchange Item '{self.item.get_name()}' is already in use")
        
        self.prot_boxes.append(ProtocolBox(x=x, y=0, len=0, label=self.item.get_name()))
        self.is_open = True

class DataflowTabularChart():
    def __init__(self, chain: FunctionalChain):
        self.chain = chain
        self.nodes: Dict[str, SystemBox] = {}
        self.behaviors: Dict[str, List[FunctionArrow]] = {}
        self.protocols: Dict[str, Protocol] = {}
        self.protocols_per_exchange: List[List[(str, int)]] = []
        
        self._x = 0
        for exchange in chain.get_involved_functional_exchanges():
            self.protocols_per_exchange.append([])
            try:
                self.__extract_protocols(exchange)
            except Exception as e:
                raise Exception(f"Error @ {exchange.get_name()}: {e}")
            self._x += 1
            
        # Check that all protocols are properly closed
        for protocol in self.protocols.values():
            if protocol.is_open:
                raise Exception(f"Error: Protocol '{protocol.item.get_name()}' is open after functional chain traversal") 
        
        # Compute the maximum level of protocols
        self.max_prot_level = max([ len(e) for e in self.protocols_per_exchange ])
        
        # Compute and sort protocol levels
        for ps in self.protocols_per_exchange:
            # Sort protocols by a ranking based on its length and its Arcadia level
            ps.sort(key=self.__rank_protocol_box, reverse=True)
            
            # Assign ranking to each box
            for y, (p, b) in enumerate(ps):
                self.protocols.get(p).prot_boxes[b].y = y
        
        self._x = 0
        last_exchange = None
        for exchange in chain.get_involved_functional_exchanges():
            self.__extract_components(exchange.get_source_function())
            self._x += 1
            last_exchange = exchange
        self.__extract_components(last_exchange.get_target_function())
    
    def __get_height_first_opening(self, x: int) -> FunctionArrow:
            for y, (p, b) in enumerate(self.protocols_per_exchange[x]):
                if self.protocols.get(p).prot_boxes[b].x == x:
                    return self.max_prot_level - y
            return 0
        
    def __get_height_first_closing(self, x: int) -> FunctionArrow:
            for y, (p, b) in enumerate(self.protocols_per_exchange[x]):
                if self.protocols.get(p).prot_boxes[b].x + self.protocols.get(p).prot_boxes[b].len == x+1:
                    return self.max_prot_level - y
            return 0
         
    def __rank_protocol_box(self, prot_box: (str, int)) -> (int, int):
        protocol, box = prot_box
        return (self.protocols.get(protocol).prot_boxes[box].len, self.protocols.get(protocol).level)
            
    def __extract_protocols(self, exchange):
        self.__extract_opening_protocols(exchange)
        
        # Add source behavior PC as involved in all open protocols
        for k, protocol in self.protocols.items():
            if protocol.is_open:
                protocol.add_hop()
                self.protocols_per_exchange[-1].append((k, len(protocol.prot_boxes)-1))
        
        self.__extract_closing_protocols(exchange)
    
    def __extract_opening_protocols(self, exchange):
        # Read source port's exchanges to open new functional protocols
        for out_item in exchange.get_source_port().get_outgoing_exchange_items():
            self.__open_protocol(out_item, 2)

        # Read exchanged items to open single-hop protocols
        for item in exchange.get_exchanged_items():
            self.__open_protocol(item, 2)
        
        for component_exchange in exchange.get_allocating_component_exchange():
            # Read source port's interfaces to open new protocols
            for out_interface in component_exchange.get_source_port().get_provided_interfaces():
                for out_item in out_interface.get_exchange_items():
                    self.__open_protocol(out_item, 1)
                    
            # Read exchanged items to open single-hop protocols
            # # # TODO: Fix: cannot find exchange item on Component Exchange
            # # for item in exchange.get_exchanged_items():
            # #     self.__open_protocol(item, 1)
            self.__open_protocol(component_exchange, 1)
            
            # TODO: also check get_allocating_physical_path()
            for link in component_exchange.get_allocating_physical_link():
                self.__open_protocol(link, 0)
    
    def __open_protocol(self, item, level: int):
        iid = item.get_id()
        if iid in self.protocols:
            self.protocols.get(iid).open(self._x)
        else:
            self.protocols.update({ iid: Protocol(item, self._x, level) })
            
    def __extract_closing_protocols(self, exchange):
        # Read target port's exchanges to close protocols
        for in_item in exchange.get_target_port().get_incoming_exchange_items():
            self.__close_protocol(in_item)

        # Read exchanged items to close single-hop protocols
        for item in exchange.get_exchanged_items():
            self.__close_protocol(item)
        
        for component_exchange in exchange.get_allocating_component_exchange():
            # Read target port's interfaces to close protocols
            for in_interface in component_exchange.get_target_port().get_provided_interfaces():
                for in_item in in_interface.get_exchange_items():
                    self.__close_protocol(in_item)

            # Read exchanged items to close single-hop protocols
            # # # TODO: Fix: cannot find exchange item on Component Exchange
            # # for item in exchange.get_exchanged_items():
            # #     self.__close_protocol(component_exchange)
            self.__close_protocol(component_exchange)

            # TODO: also check get_allocating_physical_path()
            for link in component_exchange.get_allocating_physical_link():
                self.__close_protocol(link)

    def __close_protocol(self, item):
        self.protocols.get(item.get_id()).close()
    
    def __extract_nodes(self, component):
        ns = component.get_deploying_node_p_cs()
        if len(ns) != 1:
            raise Exception(f"Behavior PC '{component.get_name()}' is not deployed on one and only one Node PC")
        node = ns[0]
            
        nid = node.get_id()
        if nid in self.nodes:
            self.nodes[nid].end=self._x
        else:
            self.nodes[nid] = SystemBox(start=self._x, end=self._x, label=node.get_name())
    
    def __extract_components(self, fn):
        component = fn.get_allocating_component()
        
        # Compute function arrows' height using sorted protocol levels
        ho = 0 if self._x == len(self.protocols_per_exchange) else self.__get_height_first_opening(self._x)
        hc = 0 if self._x-1 < 0 else self.__get_height_first_closing(self._x-1)
        
        arrow = FunctionArrow(x=self._x, height=max(ho, hc), label=component.get_name())
        if component.get_id() not in self.behaviors:
            self.behaviors[component.get_id()] = [arrow]
        else:
            self.behaviors[component.get_id()].append(arrow)
        
        self.__extract_nodes(component)
        
        return component.get_id()


dtc = DataflowTabularChart(elem)
    
# Create SVG output
output_driver = SVGOutput(verbose=False, max_prot_level=dtc.max_prot_level)
        
# Initialize output
output_driver.init_out(config={})
    
print("Drawing system boxes")
for box in dtc.nodes.values():
    output_driver.make_system_box(box)

print("Drawing protocol boxes")
for protocol in dtc.protocols.values():
    for prot_box in protocol.prot_boxes:
        output_driver.make_prot_box(prot_box)

print("Drawing function arrows")
for arrows in dtc.behaviors.values():
    for arrow in arrows:
        output_driver.make_function_arrow(arrow)

# Save output
path = Path(CapellaPlatform.getAbsolutePath(folder))
path.mkdir(parents=True, exist_ok=True)
path = path.joinpath(f"dtc_{elem.get_name()}.svg".lower().replace(' ', '_'))
print(f"Saving {path.absolute().as_posix()}")
output_driver.save(f"{path.absolute().as_posix()}")

CapellaPlatform.refresh(folder)
